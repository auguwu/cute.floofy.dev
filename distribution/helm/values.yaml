# üêª‚Äç‚ùÑÔ∏èüíê ume: Easy, self-hostable, and flexible image host made in Rust
# Copyright 2021-2024 Noel Towa <cutie@floofy.dev>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

## @section Global Parameters
## @descriptionStart
## Contains any global parameters that will affected all objects in the `ume` Helm chart.
## @descriptionEnd
##
## @param global.replicas Amount of replicas to spawn
## @param global.resources Resource list to apply to all containers.
## @param global.fullNameOverride String to fully override the Helm installation name for all objects
## @param global.nameOverride String to override the Helm installation name for all objects, will be in conjunction with a prefix of `<install-name>-`
## @param global.clusterDomain Domain host that maps to the cluster
## @param global.nodeSelector Selector labels to apply to contraint the pods to specific nodes. Read more in the [Kubernetes documentation](https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector).
## @param global.tolerations List of all taints/tolerations to apply in conjunction with `global.affinity`. Read more in the [Kubernetes documentation](https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration)
## @param global.affinity Map of all the affinity to apply to the spawned Pods. Read more in the [Kubernetes documentation](https://kubernetes.io/docs/tasks/configure-pod-container/assign-pods-nodes-using-node-affinity/).
## @param global.annotations Map of annotations to append to on all objects that this Helm chart creates.
## @param global.extraEnvVars List of extra environment variables to append to all init/sidecar containers and normal containers.
## @param global.initContainers List of init containers to create.
## @param global.podSecurityContext Security context for all spawned Pods. Read more in the [Kubernetes documentation](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/).
## @param global.containerSecurityContext Security context for all init, sidecar, and normal containers. Read more in the [Kubernetes documentation](https://kubernetes.io/docs/tasks/configure-pod-container/security-context/).
global:
  replicas: 1
  fullNameOverride: ""
  nameOverride: ""
  clusterDomain: cluster.local
  nodeSelector: {}
  tolerations: []
  affinity: {}
  annotations: {}
  extraEnvVars: []
  initContainers: []
  podSecurityContext: {}
  containerSecurityContext: {}
  resources:
    {}
    ## Example:
    ##  limits:
    ##    memory: 2Gi
    ##    cpu: 1500m
    ##  requests:
    ##    memory: 512Mi
    ##    cpu: 150m

## @section Docker Image Parameters
## @descriptionStart
## Parameters to modify the Docker image that is ran.
## @descriptionEnd
##
## @param image.pullPolicy [string] [Pull policy](https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy) when pulling the image.
## @param image.registry Registry URL to point to. For Docker Hub, use an empty string.
## @param image.image Image name.
## @param image.tag The tag of the image. Keep this as a empty string if you wish to use the default app's version.
## @param image.digest Digest in the form of `<alg>:<hex>`, this will replace the `image.tag` property if this is not empty.
image:
  pullPolicy: IfNotPresent
  registry: "" # keep empty to use docker hub
  image: auguwu/ume
  tag: "" # keep empty for the app version
  digest: ""

## @section Service Account Parameters
## @param serviceAccount.create Whether or not if the service account should be created for this Helm installation.
## @param serviceAccount.annotations Any additional annotations to append to this ServiceAccount
## @param serviceAccount.name The name of the service account, this will be the Helm installation name if this is empty.
serviceAccount:
  create: true
  annotations: {}
  name: ""

## @section Service Parameters
## @param service.enabled whether or not to create a [Service] object.
## @param service.type What type of service is this?
## @param service.labels Map of labels to append to
## @param service.annotations Map of annotations to append to
## @param service.selector Service selector to select pods
## @param service.clusterIP sets the cluster IP if `service.type` is ClusterIP
## @param service.loadBalancer Load balancer configuration if `service.type` is LoadBalancer
## @param service.externalName External name if `service.type` is ExternalName
## @param service.ports.http If you edited the port to use for the Ume server, this is where you should set it.
service:
  enabled: true
  type: ClusterIP
  labels: {}
  annotations: {}
  selector: {}
  clusterIP: ""
  loadBalancer: {}
  externalName: ""
  ports:
    http: 3621

## @section Ingress Parameters
## @param ingress.enabled whether or not if Ingress is enabled
## @param ingress.className Class name for the ingress
## @param ingress.apiVersion API version of the Ingress if it wasn't auto-detected
## @param ingress.hostname Host name of the Ume server
## @param ingress.path Path to point to when connecting to the Ume server
## @param ingress.pathType the [Type of path](https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types) to use.
## @param ingress.servicePort Port to the Ume service
## @param ingress.tls whether or not if TLS is enabled on the Ingress
## @param ingress.selfSigned whether or not if the Ingress record should create a self-signed TLS record that Helm will generate
## @param ingress.extraHosts List of extra hosts to append
## @param ingress.extraRules List of extra rules to append
## @param ingress.extraTls List of extra TLS certificates to append
ingress:
  enabled: false
  className: ""
  apiVersion: ""
  hostname: ume.local
  path: /
  pathType: ImplementationSpecific
  servicePort: http
  tls: false
  selfSigned: false
  extraHosts: []
  extraTls: []
  extraRules: []

## @section Configuration
## @param config.sentryDsn Sentry [DSN](https://docs.sentry.io/product/sentry-basics/concepts/dsn-explainer) to connect to, which will report all errors to that Sentry project.
## @param config.uploaderKey.value The value of the uploader key, this can be intepreted as a Helm template.
## @param config.uploaderKey.existingSecret If the uploader key already exists, then this will be the secret name that the uploader key will be generated from
## @param config.uploaderKey.key The key name to lookup the uploader key in that secret.
## @param config.logging.logstashTcpUrl TCP-based server URI to connect to, which will report all errors to. This can be dangerous if `config.logging.level` is `debug` or higher.
## @param config.logging.level Log level to use when showing logs in the terminal. Highest is TRACE and lowest is ERROR
## @param config.logging.json Reports all logs in the terminal as JSON input. This follows Noelware's Log Output Schema.
## @param config.tracing.enabled Enables tracing via Sentry or OpenTelemetry
## @param config.tracing.backend Sets what backend to use, `sentry` and `opentelemetry`/`otel` is the only values you can use.
## @param config.tracing.sentry.sampleSet The sample set as a float from 0.0 to 1.0 to trace all samples as.
## @param config.tracing.opentelemetry.labels Extra labels to report. This will include the `service.name` as `ume` and the `ume.version` to the version of Ume you're running.
## @param config.tracing.opentelemetry.kind Kind of endpoint we should use, `grpc` and `http` are the only accepted values.
## @param config.tracing.opentelemetry.url URL to a OpenTelemetry Collector instance
## @param config.server.host Host to bind to when creating the Ume server
## @param config.server.port Port to bind to, this will create the `http` port in the container.
## @param config.server.ssl.enabled whether or not to enable SSL
## @param config.server.ssl.caPath Path to a certificate where the Ume server will use.
## @param config.server.ssl.keyPath Path to a certificate key where the Ume server will use
config:
  sentryDsn: ""
  uploaderKey:
    value: "{{ randAlphaNum 32 }}"
    existingSecret: ""
    key: ume-uploader-key
  logging:
    logstashTcpUrl: ""
    level: info
    json: false
  tracing:
    enabled: false
    backend: ""
    sentry:
      sampleSet: 0.5
    opentelemetry:
      labels: {}
      kind: grpc
      url: grpc://localhost:4318
  server:
    host: 0.0.0.0
    port: 3621
    ssl:
      enabled: false
      caPath: /app/noel/ume/certs/server.pem
      keyPath: /app/noel/ume/certs/server.key

## @section Storage Parameters
## @descriptionStart
## Configures the storage to host all files in. This will configure the [`storage`](https://floofy.dev/docs/ume/latest/self-hosting/configuration#storage-block)
## in the `ume.hcl` configuration file.
## @descriptionEnd
##
## @param storage.filesystem.enabled whether or not to use the local disk instead
## @param storage.filesystem.directory The directory that will be mounted onto the container.
## @param storage.filesystem.persistence.enabled whether or not to persist the filesystem (`storage.filesystem.directory`) as a [PersistentVolumeClaim](https://kubernetes.io/docs/concepts/storage/persistent-volumes).
## @param storage.filesystem.persistence.existingClaim an existing PVC
## @param storage.filesystem.persistence.storageClassName choses which storage class the cluster should provision the PVC as, this is usually not included to use the default storage class configured by the cluster.
## @param storage.filesystem.persistence.annotations Map of [annotations](https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/) to append to the PVC
## @param storage.filesystem.persistence.labels Map of [labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels) to append to the PVC
## @param storage.filesystem.persistence.accessModes List of allowed ways to interact with the PVC when it is mounted. The default is recommended, but you can read the [docs](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes) for what options are available.
## @param storage.filesystem.persistence.size How large the PVC should be
## @param storage.filesystem.persistence.selector Any additional selectors that the PVC needs
## @param storage.s3.enabled Enables the use of Amazon S3, this will use the [`storage "s3" {}`](https://floofy.dev/docs/ume/latest/self-hosting/configuration#storage-s3-block) block.
## @param storage.s3.enableSignerV4Requests Whether if the S3 storage backend should enable AWSv4 signatures when requests come in or not.
## @param storage.s3.enforcePathAccessStyle Whether or not to use domain-style paths or the new path style. (`false` = `{bucket}.{host}`; `true` = `{host}/{bucket}`)
## @param storage.s3.defaultObjectAcl Default canned ACL for all published objects
## @param storage.s3.defaultBucketAcl Default bucket ACL when the [`storage.s3.bucket`](https://floofy.dev/docs/ume/latest/self-hosting/configuration#storage-s3-bucket) is not available on the account.
## @param storage.s3.appName Application name.
## @param storage.s3.prefix Selector prefix to use when looking up artifacts with the `GET /images/{id}` endpoint, this is useful if you have a filesystem-like architecture for your buckets.
## @param storage.s3.region AWS region where the bucket resides in.
## @param storage.s3.bucket The bucket itself, it'll default to `ume`.
## @param storage.s3.secrets.accessKeyId.secret The actual secret that will be created as a Kubernetes secret.
## @param storage.s3.secrets.accessKeyId.existingSecret If an existing secret already exists, this is where you put it in instead of creating one.
## @param storage.s3.secrets.accessKeyId.secretKeyName The name of the secret to find the access key ID.
## @param storage.s3.secrets.secretAccessKey.secret
## @param storage.s3.secrets.secretAccessKey.existingSecret
## @param storage.s3.secrets.secretAccessKey.secretKeyName
## @param storage.azure.enabled
## @param storage.azure.container
## @param storage.azure.credential.kind
## @param storage.azure.credential.sasToken.secret
## @param storage.azure.credential.sasToken.existingSecret
## @param storage.azure.credential.sasToken.secretKeyName
## @param storage.azure.credential.bearer.secret
## @param storage.azure.credential.bearer.existingSecret
## @param storage.azure.credential.bearer.secretKeyName
## @param storage.azure.credential.accessKey.accountId
## @param storage.azure.credential.accessKey.accessKey.secret
## @param storage.azure.credential.accessKey.accessKey.existingSecret
## @param storage.azure.credential.accessKey.accessKey.secretKeyName
## @param storage.azure.location.kind
## @param storage.azure.location.public.accountId
## @param storage.azure.location.china.accountId
## @param storage.azure.location.emulator.address
## @param storage.azure.location.emulator.port
## @param storage.gridfs.enabled
## @param storage.gridfs.selectionCriteria
## @param storage.gridfs.writeConcern
## @param storage.gridfs.readConcern
## @param storage.gridfs.chunkSize
## @param storage.gridfs.database
## @param storage.gridfs.bucket
## @param storage.gridfs.clientOptions.hosts
## @param storage.gridfs.clientOptions.appName
## @param storage.gridfs.clientOptions.directConnection
## @param storage.gridfs.clientOptions.connectTimeout
## @param storage.gridfs.clientOptions.credential.kind
## @param storage.gridfs.clientOptions.credential.userPass.username
## @param storage.gridfs.clientOptions.credential.userPass.password
## @param storage.gridfs.clientOptions.credential.userPass.existingSecret
## @param storage.gridfs.clientOptions.credential.userPass.usernameSecretKey
## @param storage.gridfs.clientOptions.credential.userPass.passwordSecretKey
## @param storage.gridfs.clientOptions.credential.mechanism
## @param storage.gridfs.clientOptions.credential.mechanismProperties
## @param storage.gridfs.clientOptions.heartbeatFrequency
## @param storage.gridfs.clientOptions.loadBalanced
## @param storage.gridfs.clientOptions.localThreshold
## @param storage.gridfs.clientOptions.maxIdleTime
## @param storage.gridfs.clientOptions.maxPoolSize
## @param storage.gridfs.clientOptions.minPoolSize
## @param storage.gridfs.clientOptions.maxConnecting
## @param storage.gridfs.clientOptions.retryReads
## @param storage.gridfs.clientOptions.retryWrites
## @param storage.gridfs.clientOptions.serverSelectionTimeout
## @param storage.gridfs.clientOptions.srvMaxHosts
## @param storage.gridfs.clientOptions.tls.enabled
## @param storage.gridfs.clientOptions.tls.allowInvalidCertificates
## @param storage.gridfs.clientOptions.tls.caFilePath
## @param storage.gridfs.clientOptions.tls.certKeyFilePath
## @param storage.gridfs.clientOptions.tls.allowInvalidHostnames
storage:
  filesystem:
    enabled: true
    directory: /var/lib/noel/ume/data
    persistence:
      enabled: true
      existingClaim: ""
      storageClassName: ""
      annotations: {}
      labels: {}
      accessModes: [ReadWriteOnce]
      size: 8GiB
      selector: {}
  s3:
    enabled: false
    enableSignerV4Requests: false
    enforcePathAccessStyle: false
    defaultObjectAcl: bucket-owner-full-control
    defaultBucketAcl: private
    appName: "Noel/ume"
    prefix: null
    region: us-east-1
    bucket: ume
    secrets:
      accessKeyId:
        secret: ""
        existingSecret: ""
        secretKeyName: access-key-id
      secretAccessKey:
        secret: ""
        existingSecret: ""
        secretKeyName: secret-access-key
  azure:
    enabled: false
    container: ume
    credential:
      kind: anonymous
      sasToken:
        secret: ""
        existingSecret: ""
        secretKeyName: azure-sas-token
      bearer:
        secret: ""
        existingSecret: ""
        secretKeyName: azure-sas-token
      accessKey:
        accountId: ""
        accessKey:
          secret: ""
          existingSecret: ""
          secretKeyName: account-access-key
    location:
      kind: public
      public:
        accountId: ""
      china:
        accountId: ""
      emulator:
        address: ""
        port: 10000
  gridfs:
    enabled: false
    selectionCriteria: null
    writeConcern: null
    readConcern: null
    chunkSize: 261120
    database: ume
    bucket: ume
    clientOptions:
      hosts: ["mongodb://localhost:27017"]
      appName: "Noel/ume"
      connectTimeout: 10000
      directConnection: false
      credential:
        kind: anonymous
        mechanism: ""
        mechanismProperties: {}
        userPass:
          username: ""
          password: ""
          existingSecret: ""
          usernameSecretKey: gridfs-username
          passwordSecretKey: gridfs-password
      heartbeatFrequency: 10000
      loadBalanced: false
      localThreshold: 15
      maxIdleTime: null
      maxPoolSize: 10
      minPoolSize: 1
      maxConnecting: 2
      retryReads: true
      retryWrites: false
      serverSelectionTimeout: 30000
      srvMaxHosts: 3
      tls:
        enabled: false
        allowInvalidCertificates: false
        caFilePath: /app/noel/ume/certs/cert.ca
        certKeyFilePath: /app/noel/ume/certs/cert.key
        allowInvalidHostnames: false
